#! /usr/bin/env perl

use strict;
use warnings; 
use FindBin qw($Bin);
use lib ( -d "$Bin/../lib/perl5" ? "$Bin/../lib/perl5" : "$Bin/../lib" );
use Carp;
use Readonly;
use Getopt::Long;
use DateTime;
use DateTime::Duration;
use DateTime::Format::Strptime;
use npg_tracking::Schema;

our $VERSION = '0';

Readonly::Scalar my $HUNDRED         => 100;
Readonly::Scalar my $DURATION_MONTHS => 3;
Readonly::Scalar my $DT_PARSER =>
  DateTime::Format::Strptime->new(pattern => "%F %T", on_error  => 'croak');

my $num_months = $DURATION_MONTHS;
my $from_string;
my $to_string;

GetOptions ("from=s"     => \$from_string,
            "to=s"       => \$to_string,
            "nmonths=i"  => \$num_months)
  or croak("Error in command line arguments\n");

($num_months > 0 && $num_months < 12) ||
  croak "Number of months $num_months failed validation";
my $to   = $to_string     ? $DT_PARSER->parse_datetime($to_string)   : DateTime->now();
my $from = $from_string ? $DT_PARSER->parse_datetime($from_string) :
           $to->clone()->subtract_duration(DateTime::Duration->new(months => $num_months));
$to->subtract_datetime_absolute($from)->is_positive() ||
  croak q['to' time should be later than 'from' time];

Readonly::Scalar my $ST => npg_tracking::Schema->connect()->storage();

sub _was_down {
  my ($id_instrument, $date)= @_;
  my $s = qq{
    select ist.date, isd.description
    from instrument_status ist, instrument_status_dict isd
    where ist.id_instrument_status_dict = isd.id_instrument_status_dict and
          ist.id_instrument = $id_instrument and
          ist.date < '$date'
    order by ist.date desc
  };

  my $rows = $ST->dbh_do(
    sub {
      my ($storage, $dbh, @args) = @_; 
      $dbh->selectall_arrayref($s, { Slice => {} });
    }
  );
  # The instrument was down at the start of the interval
  # if most recent preceeding status was (planned|down for) (repair/service)
  return @{$rows} && ($rows->[0] =~ /repair|service/);
}

sub _duration {
  my ($start, $finish) = @_;
  my $dur = $DT_PARSER->parse_datetime($finish)
    ->subtract_datetime_absolute($DT_PARSER->parse_datetime($start));
  if ($dur->is_negative()) {
    croak 'Down time is negative';
  }
  return $dur->seconds();
}

sub _compute {
  my ($head, $start, $finish) = @_;
  $head->{'down_time'}  += _duration($start, $finish);
  $head->{'down_count'} += 1;
  return;
}

sub _uptime {
  my ($down_time, $all_time) = @_;
  
  if ($all_time < $down_time) {
    croak 'Suspected time swap';
  }
  my $up = $HUNDRED;
  if ($down_time) {
    $up = (($all_time - $down_time)/$all_time) * $HUNDRED;
  }
  return sprintf '%.1f', $up;
}

my $now          = $DT_PARSER->format_datetime($to);
my $start_time   = $DT_PARSER->format_datetime($from);
my $all_time     = _duration($start_time, $now);

# Report title
print qq[ILLUMINA SEQUENCING INSTRUMENTS UPTIME FROM $start_time TO $now\n\n];

my $statement = qq{
  select ifr.model, i.id_instrument, i.name, i.iscurrent, isd.description,
         ist.date, ist.id_instrument_status
  from instrument_format ifr, instrument i, instrument_status ist, instrument_status_dict isd
  where ist.id_instrument=i.id_instrument and
        ist.id_instrument_status_dict=isd.id_instrument_status_dict and
        i.id_instrument_format=ifr.id_instrument_format and 
        ifr.model not in ('Cluster Station', 'cBot') and
        isd.description in ('down for repair', 'down for service', 'wash required') and
        (ist.date > '$start_time' and ist.date < '$now')
  order by ifr.model, i.name , ist.date, isd.description};

my $rows = $ST->dbh_do(
  sub {
    my ($storage, $dbh, @args) = @_; 
    $dbh->selectall_arrayref($statement, { Slice => {} });
  }
);

if (!$rows || !@{$rows}) {
  croak 'No rows returned';
}

my $num_statuses = scalar @{$rows};
my @instruments = ();
my $i = 0;

while ($i < $num_statuses) {

  # Get next result to consider.
  my $row = $rows->[$i];

  # Get the currently considered instrument.
  my $head     = $instruments[-1];
  my $old_head = $head;
  if (!$head || ($row->{'name'} ne $head->{'name'})) {
    # Create a new instrument entry.
    my $instrument = {};
    $instrument->{'name'}       = $row->{'name'};
    $instrument->{'model'}      = $row->{'model'};
    $instrument->{'iscurrent'}  = $row->{'iscurrent'};
    $instrument->{'down_count'} = 0;
    $instrument->{'down_time'}  = 0;
    push @instruments,$instrument;
    $head = $instrument;
  }

  if ($row->{'description'} eq 'wash required') {
    if ($old_head->{'name'} ne $head->{'name'}) {
      # First retrieved status for a given instrument is 'wash required'
      # so it might have followed down time.
      if (_was_down($row->{'id_instrument'}, $row->{'date'})) {
        _compute($head, $start_time, $row->{'date'});
      }
    }
  } else {
    # One of down statuses.
    # Move to the end of this down time or, if it's the last status
    # for the instrument, use current time.
    my $j = $i + 1;
    my $next = ($j != $num_statuses) ? $rows->[$j] : undef;
    my $start  = $row->{'date'};
    my $finish = $now;
    if ($next && $next->{'name'} eq $head->{'name'}) {
      $i = $j; # Skip over the next row.
      if ($next->{'description'} ne 'wash required') {
        croak 'Wash required status is expected';
      }
      $finish = $next->{'date'};
    }
    _compute($head, $start, $finish);
  }

  $i++;
}

# Report header
print join qq[\t], 'Model', 'Name', 'Current', 'Uptime, %', 'Num. Times Down';
print qq[\n];
# Report lines
foreach my $in (@instruments) {
  print join qq[\t], $in->{'model'},
                     $in->{'name'},
                     $in->{'iscurrent'},
                     _uptime($in->{'down_time'}, $all_time),
                     $in->{'down_count'};
                    
  print qq[\n];
}

1;

